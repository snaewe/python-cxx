<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<title>Writing Python Extensions in C++</title>
</head>

<body bgcolor="#FFFFFF">
<b><font FACE="Times" SIZE="5">

<h1 ALIGN="center">Writing Python Extensions in C++</h1>
</font><font FACE="Times" SIZE="4">

<p ALIGN="CENTER">Paul F. Dubois, <a href="mailto:dubois1@llnl.gov">dubois1@llnl.gov</a><br>
Lawrence Livermore National Laboratory<br>
Livermore, California, U.S.A.</p>

<p ALIGN="CENTER">Barry Scott<br>
Reading, Berkshire, England<br>
<a href="mailto:barry@scottb.demon.co.uk">barry@scottb.demon.co.uk</a><br>
</p>
</font></b>

<h2><b><font FACE="Times" SIZE="4">CXX is designed to make it easier to extend Python with
C++</font></b></h2>
<font FACE="Times">

<p>CXX_Objects is a set of C++ facilities to make it easier to write Python extensions.
The chief way in which CXX makes it easier to write Python extensions is that it greatly
increases the probability that your program will not make a reference-counting error and
will not have to continually check error returns from the Python C API. CXX_Objects
integrates Python with C++ in these ways: 

<ul>
  <li>C++ exception handling is relied on to detect errors and clean up. In a complicated
    function this is often a tremendous problem when writing in C. With CXX, we let the
    compiler keep track of what objects need to be dereferenced when an error occurs.</li>
  <li>The Standard Template Library (STL) and its many algorithms plug and play with Python
    containers such as lists and tuples.</li>
  <li>The optional CXX_Extensions facility allows you to replace the clumsy C tables with
    objects and method calls that define your modules and extension objects.</li>
</ul>

<h3>Download and Installation</h3>

<p>Download CXX from <a href="ftp://ftp-icf.llnl.gov/pub/python/CXX.tgz">ftp://ftp-icf.llnl.gov/pub/python/CXX.tgz</a>.
The distribution contains header files in directory Include, C and C++ source files in
directory Src, this documentation in directory Doc, and a comprehensive example / test
routine in directory Demo.</p>
</font>

<p><font FACE="Times">To use CXX you use its include files and add its source routines to
your module. There is no &quot;install&quot;. You might consider adding the include files
to $PYTHON/include/CXX and refer to them using the CXX/ prefix, e.g.,</font></p>

<p><font FACE="Times">include &quot;CXX/CXX_Objects.h&quot;</font></p>

<p><font FACE="Times">This will place them in the standard include path set up by the
standard Python package-making utilities. </font></p>

<p><font FACE="Times">The header file CXX_config.h may need to be adjusted for the
compiler you use. As of this writing, only a fairly obscure reference to part of the
standard library needs this adjustment. Unlike prior releases, CXX now assumes namespace
support and a standard C++ library. </font></p>

<h3><font FACE="Times">Use of namespaces</font></h3>

<p><font FACE="Times">All CXX assets are in namespace &quot;Py&quot;. You need to include
the Py:: prefix when referring to them, or include the statement:</font></p>

<p><font FACE="Times">using namespace Py;</font></p>

<h2><font FACE="Times">Wrappers for standard objects: CXX_Objects.h</font></h2>

<p><font FACE="Times">Header file CXX_Objects.h requires adding file Src/cxxsupport.cxx to
your module sources. CXX_Objects provides a set of wrapper classes that allow you access
to most of the Python C API using a C++ notation that closely resembles Python. For
example, this Python:</font></p>

<p><font FACE="Times">d = {}<br>
d[&quot;a&quot;] = 1<br>
d[&quot;b&quot;] = 2<br>
alist = d.keys()<br>
print alist</font></p>

<p><font FACE="Times">can be written in C++:</font></p>

<p><font FACE="Times">Dict d;<br>
List alist;<br>
d[&quot;a&quot;] = Int(1);<br>
d[&quot;b&quot;] = Int(2);<br>
alist = d.keys();<br>
std::cout &lt;&lt; alist &lt;&lt; std::endl;</font></p>

<p><font FACE="Times">You can optionally use the CXX_Extensions facility described later
to define Python extension modules and extension objects.</font></p>
<font FACE="Times" SIZE="4"><b>

<h3><a id="h_2">We avoid programming with Python object pointers</h3>
</b></font><font FACE="Times">

<p>The essential idea is that we avoid, as much as possible, programming with pointers to
Python objects, that is, variables of type </font><font FACE="Courier">PyObject*</font><font
FACE="Times">. Instead, we use instances of a family of C++ classes that represent the
usual Python objects. This family is easily extendible to include new kinds of Python
objects.</p>

<p>For example, consider the case in which we wish to write a method, taking a single
integer argument, that will create a Python </font><font FACE="Courier">dict</font><font
FACE="Times"> and insert into it that the integer plus one under the key </font><font
FACE="Courier">value</font><font FACE="Times">. In C we might do that as follows:</p>

<pre>static PyObject*
mymodule_addvalue (PyObject* self, PyObject* args) {
	PyObject *d;
	PyObject* f;
	int k;
	PyArgs_ParseTuple(args, &quot;i&quot;, &amp;k);
	d = PyDict_New();
	if (!d) {
		return NULL;
	}
	f = PyInt_NEW(k+1);
	if(!f) {
		Py_DECREF(d); /* have to get rid of d first */
		return NULL;
	}
	if(PyDict_SetItemString(d, &quot;value&quot;, f) == -1) {
		Py_DECREF(f);
		Py_DECREF(d);
		return NULL;
	}
	return d;
}</pre>

<p>If you have written a significant Python extension, this tedium looks all too familiar.
The vast bulk of the coding is error checking and cleanup. Now compare the same thing
written in C++ using CXX_Objects. The things with Python-like names (Int, Dict, Tuple) are
from CXX_Objects.</p>

<pre>static PyObject* 
mymodule_addvalue (PyObject* self, PyObject* pargs) { 
	try { 
		Tuple args(pargs); 
		args.verify_length(1); 
		Dict d; 
		Int k = args[0]; 
		d[&quot;value&quot;] = k + 1;
		return new_reference_to(d); 
	} 
	catch (const PyException&amp;) { 
		return NULL;
	}
}</pre>

<p>If there aren&#146;t the right number of arguments or the argument isn&#146;t an
integer, an exception is thrown. In this case we choose to catch it and convert it into a
Python exception. C++&#146;s exception handling mechanism takes care all the cleanup.</p>
<em>

<p></em>Note that the creation of the Int k got the first argument <em>and</em> verified
that it is an Int. <em></p>
</em></font>

<p><font FACE="Times">Just to peek ahead, if you wrote this method in an
ExtensionModule-derived module of your own, it would be a method and it could be written
even more simply:</font></p>

<blockquote>
  <p></a><font FACE="Times">Object addvalue (Object&amp; self, const Tuple&amp; args)<br>
  {<br>
  &nbsp;&nbsp;&nbsp; args.verify_length(1);<br>
  &nbsp;&nbsp;&nbsp; Dict d;<br>
  &nbsp;&nbsp;&nbsp; Int k = args[0];<br>
  &nbsp;&nbsp;&nbsp; d[&quot;value&quot;] = k + 1;<br>
  &nbsp;&nbsp;&nbsp; return d;<br>
  }</font><a id="h_2"></p>
</blockquote>
<font FACE="Times" SIZE="4"><b>

<h2></a><a id="h_3">The basic concept is to wrap Python pointers</h2>
</b></font><font FACE="Times">

<p>The basic concept of CXX_Objects is to create a wrapper around </font><font
FACE="Courier">PyObject*</font><font FACE="Times">s so that the reference counting can be
done automatically, thus eliminating the most frequent source of errors. In addition, we
can then add methods and operators so that Python manipulations in C++ can look more like
Python. </p>

<p>Each </font><font FACE="Courier">Object</font><font FACE="Times"> contains a </font><font
FACE="Courier">PyObject*</font><font FACE="Times"> to which it owns a reference. When an </font><font
FACE="Courier">Object</font><font FACE="Times"> is destroyed, it releases its ownership on
the pointer. Since C++ calls the destructors on objects that are about to go out of scope,
we are guaranteed that we will keep the reference counts right even if we unexpectedly
leave a routine with an exception.</p>

<p>As a matter of philosophy, CXX_Objects prevents the creation of instances of its
classes unless the instance will be a valid instance of its class. When an attempt is made
to create an object that will not be valid, an exception is thrown.</p>

<p>Class Object represents the most general kind of Python object. The rest of the classes
that represent Python objects inherit from it.</p>

<p>Object<br>
&nbsp;&nbsp;&nbsp; Type<br>
&nbsp;&nbsp;&nbsp; Int<br>
&nbsp;&nbsp;&nbsp; Float<br>
&nbsp;&nbsp;&nbsp; Long<br>
&nbsp;&nbsp;&nbsp; Complex<br>
&nbsp;&nbsp;&nbsp; Char<br>
&nbsp;&nbsp;&nbsp; Sequence -&gt; SeqBase&lt;T&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tuple<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List<br>
&nbsp;&nbsp;&nbsp; Mapping -&gt; MapBase&lt;T&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dict<br>
&nbsp;&nbsp;&nbsp; Callable<br>
&nbsp;&nbsp;&nbsp; Module</p>

<p>There are several constructors for each of these classes. For example, you can create
an Int from an integer as in</p>

<pre>Int s(3)</pre>

<p>However, you can also create an instance of one of these classes using any PyObject* or
another Object. If the corresponding Python object does not actually have the type
desired, an exception is thrown. This is accomplished as follows. Class Object defines a
virtual function accepts:</p>

<pre>virtual bool accepts(PyObject* p)</pre>

<p>The base class version of accepts returns true for any pointer p except 0. This means
we can create an Object using any <font FACE="Courier">PyObject*, </font>or from any other
Object. However, if we attempt to create an Int from a PyObject*, the overridding version
of accepts in class Int will only accept pointers that correspond to Python ints.
Therefore if we have a Tuple t and we wish to get the first element and be sure it is an
Int, we do</p>

<p>Int first_element = t[0]</p>

<p>This will not only accomplish the goal of extracting the first element of the Tuple t,
but it will ensure that the result is an Int. If not, an exception is thrown. (The
exception mechanism is discussed later.)</p>

<h2></a><a id="h_4">Class Object</h2>

<p>Class Object serves as the base class for the other classes. Its default constructor
constructs a Py_None, the unique object of Python type None. The interface to Object
consists of a large number of methods corresponding to the operations that are defined for
every Python object. In each case, the methods thow an exception if anything goes
wrong.There is no method corresponding to PyObject_SetItem with an arbitrary Python object
as a key. Instead, create an instance of a more specific child of Object and use the
appropriate facilities.</p>

<p>The comparison operators use the Python comparison function to compare values. The
method &quot;is&quot; is available to test for absolute identity.&nbsp; </p>

<p>A conversion to standard library string type std::string is supplied using method
&quot;as_string&quot;. Stream output of Objects uses this conversion, which in turn uses
the Python object's str() representation.</p>

<p>All the numeric operators are defined on all possible combinations of Object, long, and
double. These use the corresponding Python operators, and should the operation fail for
some reason, an exception is thrown.</p>

<h3>Dealing with pointers returned by the Python C API</h3>
</a><a id="h_3">

<p>Often, <font FACE="Courier">PyObject*</font> pointers are acquired from some function,
particularly functions in the Python C API. If you wish to make an object from the pointer
returned by such a function, you need to know if the function returns you an <i>owned</i>
or <i>unowned</i> reference. Unowned references are unusual but there are some cases where
unowned references are returned. </p>

<p>Usually, Object and its children acquire a new reference when constructed from a
PyObject *.&nbsp; This is usually not the right behavior if the reference comes from one
of the Python C API calls.</p>

<p>If p is an owned reference, you can add the boolean &quot;true&quot; as an extra
argument in the creation routine, Object(p, true), or use the function asObject(p) which
returns an Object created using the owned reference. For example, the routine
PyString_FromString returns an owned reference to a Python string object. You could write:</p>

<p>Object w = asObject(PyString_FromString(&quot;my string&quot;));</p>

<p>or using the constructor,</p>

<p>Object w (PyString_FromString(&quot;my string&quot;), true);</p>

<p>In fact, you would never do this, since CXX has a class String and you can just say: </p>

<p>String w(&quot;my string&quot;)</p>

<p>Indeed, since most of the Python C API is similarly embodied in <font FACE="Courier">Object</font>
and its descendents, you probably will not use asObject all that often.</p>
</a><a id="h_4">

<h3></a><a id="h_5">Table 1: Class Object<b></h3>
</b></font><div align="center"><center>

<table BORDER="1" CELLSPACING="1">
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font FACE="Times"><p ALIGN="CENTER"><strong>Returns</strong></font></td>
    <td WIDTH="47%" VALIGN="TOP"><font FACE="Times"><p ALIGN="CENTER"><strong>Name(signature)</strong></font></td>
    <td WIDTH="38%" VALIGN="TOP"><font FACE="Times"><p ALIGN="CENTER"><strong>Comment</strong></font></td>
  </tr>
  <tr>
    <td WIDTH="101%" VALIGN="TOP" colspan="3"><font FACE="Times"><p align="center"><strong>Basic
    Methods</strong></font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font FACE="Times">explicit </font></td>
    <td WIDTH="47%" VALIGN="TOP"><font FACE="Times"><font color="#008000">Object</font>
    (PyObject* pyob=Py_None, bool owned=false) </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font FACE="Times">Construct from pointer. </font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font FACE="Times">explicit</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font FACE="Times"><font color="#008000">Object</font> (const
    Object&amp; ob)</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font FACE="Times">Copycons; acquires an owned reference.</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font FACE="Times">Object&amp;</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font FACE="Times">operator= (const Object&amp; rhs) </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font FACE="Times">Acquires an owned reference.</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font FACE="Times">Object&amp;</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font FACE="Times">operator= (PyObject* rhsp) </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font FACE="Times">Acquires an owned reference.</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font FACE="Times" COLOR="#ff0000">virtual</font><font
    FACE="Times"> </font></td>
    <td WIDTH="47%" VALIGN="TOP"><font FACE="Times"><font color="#FF0000">~Object</font> () </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Releases the reference.</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">void</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">increment_reference_count() </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Explicitly increment the count</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">void</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">decrement_reference_count()</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Explicitly decrement count but not to zero</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">PyObject*</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">operator* () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Lends the pointer</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">PyObject*</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">ptr () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Lends the pointer</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font FACE="Times" COLOR="#ff0000">virtual</font><font
    face="Times"> bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times"><font color="#FF0000">accepts</font>
    (PyObject *pyob) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Would assignment of pyob to this object
    succeed?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">std::string</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">as_string() const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">str() representation</font></td>
  </tr>
  <tr>
    <td WIDTH="101%" VALIGN="TOP" colspan="3" align="center"><strong>Python API Interface</strong></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">int</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">reference_count () const </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">reference count</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">Type</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">type () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">associated type object</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">String</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">str () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">str() representation</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">String</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">epr () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">repr () representation</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">hasAttr (const std::string&amp; s) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">hasattr(this, s)</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">Object</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">getAttr (const std::string&amp; s) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">getattr(this, s)</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">Object</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">getItem (const Object&amp; key) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">getitem(this, key)</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">long</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">hashValue () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">hash(this)</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">void</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">setAttr (const std::string&amp; s, <br>
    const Object&amp; value)</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">this.s = value</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">void</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">delAttr (const std::string&amp; s) </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">del this.s</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">void</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">delItem (const Object&amp; key) </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">del this[key]</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isCallable () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">does this have callable behavior?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isList () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">is this a Python list?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isMapping () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">does this have mapping behaviors?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isNumeric () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">does this have numeric behaviors?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isSequence () const </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">does this have sequence behaviors?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isTrue () const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">is this true in the Python sense?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isType (const Type&amp; t) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">is type(this) == t?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isTuple() const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">is this a Python tuple?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isString() const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">is this a Python string?</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">isDict() const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">is this a Python dictionary?</font></td>
  </tr>
  <tr>
    <td WIDTH="101%" VALIGN="TOP" colspan="3" align="center"><font face="Times"><strong>Comparison
    Operators</strong></font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">is(PyObject* pother) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">test for identity</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">is(const Object&amp; other) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">test for identity</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool </font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">operator==(const Object&amp; o2) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Comparisons use Python cmp</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">operator!=(const Object&amp; o2) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Comparisons use Python cmp</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">operator&gt;=(const Object&amp; o2) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Comparisons use Python cmp</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">operator&lt;=(const Object&amp; o2) const </font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Comparisons use Python cmp</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">operator&lt;(const Object&amp; o2) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Comparisons use Python cmp</font></td>
  </tr>
  <tr>
    <td WIDTH="16%" VALIGN="TOP"><font face="Times">bool</font></td>
    <td WIDTH="47%" VALIGN="TOP"><font face="Times">operator&gt;(const Object&amp; o2) const</font></td>
    <td WIDTH="38%" VALIGN="TOP"><font face="Times">Comparisons use Python cmp</font></td>
  </tr>
</table>
</center></div>

<h1></a><a id="h_6">The Basic Types</h1>

<p>Corresponding to each of the basic Python types is a class that inherits from Object.
Here are the interfaces for those types. Each of them inherits from Object and therefore
has all of the inherited methods listed for Object. Where a virtual function is overridden
in a class, the name is underlined. </p>

<h2></a><a id="h_7">Class Type</h2>

<p>Class Type corresponds to Python type objects. There is no default constructor.</p>

<h3></a><a id="h_8">Table 2: class Type</h3>
<div align="left">

<table border="1" width="505">
  <tr>
    <td width="99"><p align="center"><strong>Returns</strong></td>
    <td width="488"><p align="center"><strong>Name and Signature</strong></td>
    <td width="129"><p align="center"><strong>Comments</strong></td>
  </tr>
  <tr>
    <td width="99">explicit&nbsp;&nbsp; </td>
    <td width="488"><font color="#008000">Type</font> (PyObject* pyob, bool owned = false)</td>
    <td width="129">Constructor</td>
  </tr>
  <tr>
    <td width="99">explicit&nbsp;&nbsp; </td>
    <td width="488"><font color="#008000">Type</font> (const Object&amp; ob)</td>
    <td width="129">Constructor</td>
  </tr>
  <tr>
    <td width="99">explicit</td>
    <td width="488"><font color="#008000">Type</font>(const Type&amp; t)</td>
    <td width="129">Copycons</td>
  </tr>
  <tr>
    <td width="99">Type&amp;&nbsp;&nbsp; </td>
    <td width="488">operator= (const Object&amp; rhs) </td>
    <td width="129">Assignment</td>
  </tr>
  <tr>
    <td width="99">Type&amp;&nbsp;&nbsp; </td>
    <td width="488">operator= (PyObject* rhsp) </td>
    <td width="129">Assignment</td>
  </tr>
  <tr>
    <td width="99"><font color="#FF0000">virtual</font> bool</td>
    <td width="488"><font color="#FF0000"><u>accepts</u></font> (PyObject *pyob) const</td>
    <td width="129">Uses PyType_Check</td>
  </tr>
</table>
</div>

<h2></a><a id="h_9">Class Int</h2>

<p>Class Int, derived publically from Object, corresponds to Python ints. Note that the
latter correspond to C long ints. Class Int has an implicit user-defined conversion to
long int. All constructors, on the other hand, are explicit. The default constructor
creates a Python int zero.</p>

<h3></a><a id="h_10">Table 3: class Int</h3>
<div align="left">

<table border="1">
  <tr>
    <td><p align="center"><strong>Returns</strong></td>
    <td><p align="center"><strong>Name and Signature</strong></td>
    <td><p align="center"><strong>Comments</strong></td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Int</font> (PyObject *pyob, bool owned= false</a><a id="h_8">,
    bool owned = false</a><a id="h_10">)</td>
    <td>Constructor</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Int</font> (const Int&amp; ob)</td>
    <td>Constructor</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Int</font> (long v = 0L)</td>
    <td>Construct from long</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Int</font> (int v)</td>
    <td>Contruct from int</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Int</font> (const Object&amp; ob)</td>
    <td>Copycons</td>
  </tr>
  <tr>
    <td>Int&amp;&nbsp;&nbsp; </td>
    <td>operator= (const Object&amp; rhs)</td>
    <td>Assignment</td>
  </tr>
  <tr>
    <td>Int&amp;&nbsp;&nbsp; </td>
    <td>operator= (PyObject* rhsp)</td>
    <td>Assignment</td>
  </tr>
  <tr>
    <td><font color="#FF0000">virtual</font> bool&nbsp;&nbsp; </td>
    <td><u><font color="#FF0000">accepts</font></u> (PyObject *pyob) const </td>
    <td>Based on PyInt_Check</td>
  </tr>
  <tr>
    <td>long</td>
    <td>operator long() const </td>
    <td><em>Implicit</em> conversion to long int</td>
  </tr>
  <tr>
    <td>Int&amp;&nbsp;&nbsp; </td>
    <td>operator= (int v)</td>
    <td>Assign from int</td>
  </tr>
  <tr>
    <td>Int&amp;&nbsp;&nbsp; </td>
    <td>operator= (long v) </td>
    <td>Assign from long</td>
  </tr>
</table>
</div>

<hr>

<h2></a><a id="h_11">Class Long</h2>

<p>Class Long, derived publically from Object, corresponds to Python type long. In Python,
a long is an integer type of unlimited size, and is usually used for applications such as
cryptography, not as a normal integer. Implicit conversions to both double and long are
provided, although the latter may of course fail if the number is actually too big. All
constructors are explicit. The default constructor produces a Python long zero.</p>

<h3></a><a id="h_12">Table 4: Class Long</h3>
<div align="left">

<table border="1">
  <tr>
    <td><p align="center"><strong>Returns</strong></td>
    <td><p align="center"><strong>Name and Signature</strong></td>
    <td><p align="center"><strong>Comments</strong></td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Long</font> (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a
    id="h_12">)</td>
    <td>Constructor</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Long</font> (const Int&amp; ob)</td>
    <td>Constructor</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Long</font> (long v = 0L)</td>
    <td>Construct from long</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Long</font> (int v)</td>
    <td>Contruct from int</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td><font color="#008000">Long</font> (const Object&amp; ob)</td>
    <td>Copycons</td>
  </tr>
  <tr>
    <td>Long&amp;&nbsp;&nbsp; </td>
    <td>operator= (const Object&amp; rhs)</td>
    <td>Assignment</td>
  </tr>
  <tr>
    <td>Long&amp;&nbsp;&nbsp; </td>
    <td>operator= (PyObject* rhsp)</td>
    <td>Assignment</td>
  </tr>
  <tr>
    <td><font color="#FF0000">virtual</font> bool&nbsp;&nbsp; </td>
    <td><u><font color="#FF0000">accepts</font></u> (PyObject *pyob) const </td>
    <td>Based on PyLong_Check</td>
  </tr>
  <tr>
    <td>double</td>
    <td>operator double() const </td>
    <td><em>Implicit</em> conversion to double</td>
  </tr>
  <tr>
    <td>long</td>
    <td>operator long() const</td>
    <td><em>Implicit</em> conversion to long</td>
  </tr>
  <tr>
    <td>Long&amp;&nbsp;&nbsp; </td>
    <td>operator= (int v)</td>
    <td>Assign from int</td>
  </tr>
  <tr>
    <td>Long&amp;&nbsp;&nbsp; </td>
    <td>operator= (long v) </td>
    <td>Assign from long</td>
  </tr>
</table>
</div>

<h2></a><a id="h_13">Class Float</h2>

<p>Class Float corresponds to Python floats, which in turn correspond to C double. The
default constructor produces the Python float 0.0. </p>

<h3></a><a id="h_14">Table 5: Class Float</h3>
<div align="left">

<table border="1" width="524">
  <tr>
    <td width="79"><p align="center"><strong>Returns</strong></td>
    <td width="232"><p align="center"><strong>Name and Signature</strong></td>
    <td width="121"><p align="center"><strong>Comments</strong></td>
  </tr>
  <tr>
    <td width="79">explicit&nbsp;&nbsp; </td>
    <td width="232">Float (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a id="h_14">)&nbsp;&nbsp;
    </td>
    <td width="121">Constructor</td>
  </tr>
  <tr>
    <td width="79">&nbsp;&nbsp; </td>
    <td width="232">Float (const Float&amp; f)&nbsp;&nbsp; </td>
    <td width="121">Construct from float</td>
  </tr>
  <tr>
    <td width="79">explicit&nbsp;&nbsp; </td>
    <td width="285">Float (double v=0.0)</td>
    <td width="62">Construct from double</td>
  </tr>
  <tr>
    <td width="79">explicit&nbsp;&nbsp; </td>
    <td width="285">Float (const Object&amp; ob)</td>
    <td width="62">Copycons</td>
  </tr>
  <tr>
    <td width="79">Float&amp;&nbsp;&nbsp; </td>
    <td width="285">operator= (const Object&amp; rhs)</td>
    <td width="62">Assignment</td>
  </tr>
  <tr>
    <td width="79">Float&amp;&nbsp;&nbsp; </td>
    <td width="285">operator= (PyObject* rhsp)</td>
    <td width="62">Assignment</td>
  </tr>
  <tr>
    <td width="79">virtual bool&nbsp;&nbsp; </td>
    <td width="285">accepts (PyObject *pyob) const</td>
    <td width="62">Based on PyFloat_Check</td>
  </tr>
  <tr>
    <td width="79">double&nbsp;&nbsp; </td>
    <td width="285">operator double () const</td>
    <td width="62"><em>Implicit</em> conversion to double</td>
  </tr>
  <tr>
    <td width="79">Float&amp;&nbsp;&nbsp; </td>
    <td width="285">operator= (double v)</td>
    <td width="62">Assign from double</td>
  </tr>
  <tr>
    <td width="79">Float&amp;&nbsp;&nbsp; </td>
    <td width="285">operator= (int v)</td>
    <td width="62">Assign from int</td>
  </tr>
  <tr>
    <td width="79">Float&amp;&nbsp;&nbsp; </td>
    <td width="285">operator= (long v)</td>
    <td width="62">Assign from long</td>
  </tr>
  <tr>
    <td width="79">Float&amp;&nbsp;&nbsp; </td>
    <td width="285">operator= (const Int&amp; iob)</td>
    <td width="62">Assign from Int</td>
  </tr>
</table>
</div>

<h1></a><a id="h_15">Sequences</h1>

<p>CXX implements a quite sophisticated wrapper class for Python sequences. While every
effort has been made to disguise the sophistication, it may pop up in the form of obscure
compiler error messages, so in this documentation we will first detail normal usage and
then discuss what is under the hood.</p>

<p>The basic idea is that we would like the subscript operator [] to work properly, and to
be able to use STL-style iterators and STL algorithms across the elements of the sequence.</p>

<p>Sequences are implemented in terms of a templated base class, SeqBase&lt;T&gt;. The
parameter T is the answer to the question, sequence of what? For Lists, for example, T is
Object, because the most specific thing we know about an element of a List is simply that
it is an Object. (Class List is defined below; it is a descendent of Object that holds a
pointer to a Python list). For strings, T is Char, which is a wrapper in turn of Python
strings whose length is one.&nbsp; </p>

<p>For convenience, the word <strong>Sequence</strong> is typedef'd to
SeqBase&lt;Object&gt;.</p>

<h2></a><a id="h_16">General sequences</h2>

<p>Suppose you are writing an extension module method that expects the first argument to
be any kind of Python sequence, and you wish to return the length of that sequence. You
might write:</p>

<p>static PyObject*<br>
my_module_seqlen (PyObject *self, PyObject* args) {<br>
&nbsp;&nbsp;&nbsp; try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tuple t(args); // set up a Tuple pointing to
the arguments.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(t.length() != 1) throw
PyException(&quot;Incorrect number of arguments to seqlen.&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequence s = t[0]; // get argument and be sure
it is a sequence<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new_reference_to(Int(s.length()));<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; catch(const PyException&amp;) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Py_Null;<br>
&nbsp;&nbsp;&nbsp; }<br>
}</p>

<p>As we will explain later, the try/catch structure converts any errors, such as the
first argument not being a sequence, into a Python exception.</p>

<h3></a><a id="h_17">Subscripting</h3>

<p>When a sequence is subscripted, the value returned is a special kind of object which
serves as a proxy object. The general idea of proxy objects is discussed in Scott Meyers'
book, &quot;More Effective C++&quot;. Proxy objects are necessary because when one
subscripts a sequence it is not clear whether the value is to be used or the location
assigned to. Our proxy object is even more complicated than normal because a sequence
reference such as s[i] is not a direct reference to the i'th object of s. </p>

<p>In normal use, you are not supposed to notice this magic going on behind your back. You
write:</p>

<p>Object t; <br>
Sequence s;<br>
s[2] = t + s[1]</p>

<p>and here is what happens: s[1] returns a proxy object. Since there is no addition
operator in Object that takes a proxy as an argument, the compiler decides to invoke an
automatic conversion of the proxy to an Object, which returns the desired component of s.
The addition takes place, and then there is an assignment operator in the proxy class
created by the s[2], and that assignment operator stuffs the result into the 2 component
of s.</p>

<p>It is possible to fool this mechanism and end up with a compiler failing to admit that
a s[i] is an Object. If that happens, you can work around it by writing Object(s[i]),
which makes the desired implicit conversion, explicit.</p>

<h3></a><a id="h_18">Iterators</h3>

<p>Each sequence class provides the following interface. The class seqref&lt;T&gt; is the
proxy class. We omit the details of the iterator, const_iterator, and seqref&lt;T&gt;
here. See CXX_Objects.h if necessary. The purpose of most of this interface is to satisfy
requirements of the STL.</p>

<h3></a><a id="h_19">The SeqBase&lt;T&gt; Interface</h3>

<p><em>SeqBase&lt;T&gt; inherits from Object</em>.</p>
<div align="left">

<table border="1">
  <tr>
    <th valign="middle" align="center"><strong>Type</strong></th>
    <th valign="middle" align="center"><strong>Name</strong></th>
  </tr>
  <tr>
    <td>typedef int </td>
    <td>size_type</td>
  </tr>
  <tr>
    <td>typedef seqref&lt;T&gt;</td>
    <td>reference</td>
  </tr>
  <tr>
    <td>typedef T </td>
    <td>const_reference</td>
  </tr>
  <tr>
    <td>typedef seqref&lt;T&gt;*</td>
    <td>pointer</td>
  </tr>
  <tr>
    <td>typedef int </td>
    <td>difference_type</td>
  </tr>
  <tr>
    <td>virtual size_type</td>
    <td>max_size() const</td>
  </tr>
  <tr>
    <td>virtual size_type </td>
    <td>capacity() const;</td>
  </tr>
  <tr>
    <td>virtual void </td>
    <td>swap(SeqBase&lt;T&gt;&amp; c);</td>
  </tr>
  <tr>
    <td>virtual size_type </td>
    <td>size () const;</td>
  </tr>
  <tr>
    <td>explicit </td>
    <td>SeqBase&lt;T&gt; ();</td>
  </tr>
  <tr>
    <td>explicit </td>
    <td>SeqBase&lt;T&gt; (PyObject* pyob</a><a id="h_8">, bool owned = false</a><a id="h_19">);</td>
  </tr>
  <tr>
    <td>explicit </td>
    <td>SeqBase&lt;T&gt; (const Object&amp; ob);</td>
  </tr>
  <tr>
    <td>SeqBase&lt;T&gt;&amp; </td>
    <td>operator= (const Object&amp; rhs);</td>
  </tr>
  <tr>
    <td>SeqBase&lt;T&gt;&amp; </td>
    <td>operator= (PyObject* rhsp);</td>
  </tr>
  <tr>
    <td>virtual bool </td>
    <td>accepts (PyObject *pyob) const;</td>
  </tr>
  <tr>
    <td>size_type </td>
    <td>length () const ;</td>
  </tr>
  <tr>
    <td>const T </td>
    <td>operator[](size_type index) const; </td>
  </tr>
  <tr>
    <td>seqref&lt;T&gt; </td>
    <td>operator[](size_type index); </td>
  </tr>
  <tr>
    <td>virtual T </td>
    <td>getItem (size_type i) const;</td>
  </tr>
  <tr>
    <td>virtual void </td>
    <td>setItem (size_type i, const T&amp; ob);</td>
  </tr>
  <tr>
    <td>SeqBase&lt;T&gt; </td>
    <td>repeat (int count) const;</td>
  </tr>
  <tr>
    <td>SeqBase&lt;T&gt; </td>
    <td>concat (const SeqBase&lt;T&gt;&amp; other) const ;</td>
  </tr>
  <tr>
    <td>const T </td>
    <td>front () const;</td>
  </tr>
  <tr>
    <td>seqref&lt;T&gt; </td>
    <td>front();</td>
  </tr>
  <tr>
    <td>const T </td>
    <td>back () const;</td>
  </tr>
  <tr>
    <td>seqref&lt;T&gt; </td>
    <td>back(); </td>
  </tr>
  <tr>
    <td>void </td>
    <td>verify_length(size_type required_size);</td>
  </tr>
  <tr>
    <td>void </td>
    <td>verify_length(size_type min_size, size_type max_size);</td>
  </tr>
  <tr>
    <td>class</td>
    <td>iterator;</td>
  </tr>
  <tr>
    <td>iterator </td>
    <td>begin (); </td>
  </tr>
  <tr>
    <td>iterator </td>
    <td>end ();</td>
  </tr>
  <tr>
    <td>class </td>
    <td>const_iterator;</td>
  </tr>
  <tr>
    <td>const_iterator </td>
    <td>begin () const;</td>
  </tr>
  <tr>
    <td>const_iterator </td>
    <td>end () const;</td>
  </tr>
</table>
</div>

<p>Any heir of class Object that has a sequence behavior should inherit from class
SeqBase&lt;T&gt;, where T is specified as the type of object that represents the
individual elements of the sequence. The requirements on T are that it has a constructor
that takes a PyObject* as an argument, that it has a default constructor, a copy
constructor, and an assignment operator. In short, any properly defined heir of Object
will work. </p>

<h2></a><a id="h_20">Classes Char and String</h2>

<p>Python strings are unusual in that they are immutable sequences of characters. However,
there is no character type per se; rather, when subscripted strings return a string of
length one. To simulate this, we define two classes Char and String. The Char class
represents a Python string object of length one. The String class represents a Python
string, and its elements make up a sequence of Char's.</p>

<p>The user interface for Char is limited. Unlike String, for example, it is not a
sequence.</p>

<h3></a><a id="h_21">The Char interface</h3>

<p><em>Char inherits from Object.</em></p>
<div align="left">

<table border="1">
  <tr>
    <td><p align="center"><strong>Type</strong></td>
    <td><p align="center"><strong>Name</strong></td>
  </tr>
  <tr>
    <td>explicit</td>
    <td>Char (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a id="h_21">)</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>Char (const Object&amp; ob)&nbsp;&nbsp;&nbsp; </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>Char (const std::string&amp; v = &quot;&quot;) </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>Char (char v)</td>
  </tr>
  <tr>
    <td>Char&amp;</td>
    <td>operator= (const std::string&amp; v)</td>
  </tr>
  <tr>
    <td>Char&amp;</td>
    <td>operator= (char v) </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>operator String() const</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>operator std::string () const </td>
  </tr>
</table>
</div>

<h3></a><a id="h_22">The String Interface</h3>

<p><em>String inherits from SeqBase&lt;Char&gt;.</em></p>
<div align="left">

<table border="1">
  <tr>
    <td><p align="center"><strong>Type</strong>&nbsp;&nbsp; </td>
    <td><p align="center"><strong>Name</strong></td>
  </tr>
  <tr>
    <td>explicit&nbsp;&nbsp; </td>
    <td>String (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a id="h_22">)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>String (const Object&amp; ob)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>String (const std::string&amp; v = &quot;&quot;)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>String (const std::string&amp; v, std::string::size_type vsize)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>String (const char* v)</td>
  </tr>
  <tr>
    <td>String&amp;</td>
    <td>operator= (const std::string&amp; v) </td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>operator std::string () const</td>
  </tr>
</table>
</div>

<h2></a><a id="h_23">Class Tuple</h2>

<p>Class Tuple represents Python tuples. A Tuple is a Sequence. There are two kinds of
constructors: one takes a PyObject* as usual, the other takes an integer number as an
argument and returns a Tuple of that length, each component initialized to Py_None. The
default constructor produces an empty Tuple. </p>

<p>Tuples are not immutable, but attempts to assign to their components will fail if the
reference count is not 1. That is, it is safe to set the elements of a Tuple you have just
made, but not thereafter.</p>

<p>Example: create a Tuple containing (1, 2, 4)</p>

<pre>Tuple t(3)
t[0] = Int(1)
t[1] = Int(2)
t[2] = Int(4)</pre>

<p>Example: create a Tuple from a list:</p>

<p>Dict d<br>
...<br>
Tuple t(d.keys())</p>

<h3></a><a id="h_24">The Tuple Interface</h3>

<p><em>Tuple inherits from Sequence.. Special run-time checks prevent modification if the
reference count is greater than one.</em></p>
<div align="left">

<table border="1">
  <tr>
    <td><p align="center"><strong>Type</strong>&nbsp;&nbsp; </td>
    <td><p align="center"><strong>Name</strong></td>
    <td><strong><p align="center">Comment</strong></td>
  </tr>
  <tr>
    <td>virtual void</td>
    <td>setItem (int offset, const Object&amp;ob) </td>
    <td>setItem is overriden to handle tuples properly. </td>
  </tr>
  <tr>
    <td>explicit</td>
    <td>Tuple (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a id="h_24">)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>Tuple (const Object&amp; ob)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td>Tuple (int size = 0)</td>
    <td>Create a tuple of the given size. Items initialize to Py_None. Default is an empty
    tuple.</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td>Tuple (const Sequence&amp; s)</td>
    <td>Create a tuple from any sequence.</td>
  </tr>
  <tr>
    <td>Tuple&amp;</td>
    <td>operator= (const Object&amp; rhs)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Tuple&amp;</td>
    <td>operator= (PyObject* rhsp)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Tuple</td>
    <td>getSlice (int i, int j) const </td>
    <td>Equivalent to python's t[i:j]</td>
  </tr>
</table>
</div>

<h2></a><a id="h_25">Class List</h2>

<p>Class List represents a Python list, and the methods available faithfully reproduce the
Python API for lists. A List is a Sequence.</p>

<h3></a><a id="h_26">The List Interface</h3>

<p><em>List inherits from Sequence.</em></p>

<table border="1" width="983">
  <tr>
    <td width="46"><p align="center"><strong>Type&nbsp;&nbsp; </strong></td>
    <td width="299"><p align="center"><strong>Name</strong></td>
    <td width="620"><strong><p align="center">Comment</strong></td>
  </tr>
  <tr>
    <td width="46">explicit</td>
    <td width="299">List (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a id="h_26">)</td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">&nbsp;&nbsp; </td>
    <td width="299">List (const Object&amp; ob)</td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">&nbsp;&nbsp; </td>
    <td width="299">List (int size = 0)</td>
    <td width="620">Create a list of the given size. Items initialized to Py_None. Default is
    an empty list.</td>
  </tr>
  <tr>
    <td width="46">&nbsp;&nbsp; </td>
    <td width="299">List (const Sequence&amp; s)</td>
    <td width="620">Create a list from any sequence.</td>
  </tr>
  <tr>
    <td width="46">List&amp;</td>
    <td width="299">operator= (const Object&amp; rhs)</td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">List&amp;</td>
    <td width="299">operator= (PyObject* rhsp)</td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">List</td>
    <td width="299">getSlice (int i, int j) const</td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">void</td>
    <td width="299">setSlice (int i, int j, const Object&amp; v) </td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">void</td>
    <td width="299">append (const Object&amp; ob)</td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">void</td>
    <td width="299">insert (int i, const Object&amp; ob)</td>
    <td width="620">&nbsp;</td>
  </tr>
  <tr>
    <td width="46">void</td>
    <td width="299">sort ()</td>
    <td width="620">Sorts the list in place, using Python's member function. You can also use
    the STL sort function on any List instance.</td>
  </tr>
  <tr>
    <td width="46">void</td>
    <td width="299">reverse ()</td>
    <td width="620">Reverses the list in place, using Python's member function.</td>
  </tr>
</table>

<h1></a><a id="h_27">Mappings</h1>

<p>A class MapBase&lt;T&gt; is used as the base class for Python objects with a mapping
behavior. The key behavior of this class is the ability to set and use items by
subscripting with strings. A proxy class mapref&lt;T&gt; is defined to produce the correct
behavior for both use and assignment.</p>

<p>For convenience, <strong>Mapping </strong>is typedefed as MapBase&lt;Object&gt;.</p>

<h3></a><a id="h_28">The MapBase&lt;T&gt; interface</h3>

<p><em>MapBase&lt;T&gt; inherits from Object. T should be chosen to reflect the kind of
element returned by the mapping.</em></p>

<table border="1">
  <tr>
    <td><p align="center"><strong>Type</strong>&nbsp;&nbsp; </td>
    <td><p align="center"><strong>Name</strong></td>
    <td><strong><p align="center">Comment</strong></td>
  </tr>
  <tr>
    <td>T</td>
    <td>operator[](const std::string&amp; key) const</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>mapref&lt;T&gt; </td>
    <td>operator[](const std::string&amp; key)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>int</td>
    <td>length () const</td>
    <td>Number of entries.</td>
  </tr>
  <tr>
    <td>int</td>
    <td>hasKey (const std::string&amp; s) const </td>
    <td>Is m[s] defined?</td>
  </tr>
  <tr>
    <td>T</td>
    <td>getItem (const std::string&amp; s) const</td>
    <td>m[s]</td>
  </tr>
  <tr>
    <td>virtual void</td>
    <td>setItem (const std::string&amp; s, const Object&amp; ob)</td>
    <td>m[s] = ob</td>
  </tr>
  <tr>
    <td>void</td>
    <td>delItem (const std::string&amp; s)</td>
    <td>del m[s]</td>
  </tr>
  <tr>
    <td>void</td>
    <td>delItem (const Object&amp; s)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>List</td>
    <td>keys () const</td>
    <td>A list of the keys.</td>
  </tr>
  <tr>
    <td>List</td>
    <td>values () const</td>
    <td>A list of the values.</td>
  </tr>
  <tr>
    <td>List</td>
    <td>items () const</td>
    <td>Each item is a key-value pair.</td>
  </tr>
</table>

<h2></a><a id="h_29">Class Dict</h2>

<p>Class Dict represents Python dictionarys.&nbsp; A Dict is a Mapping. Assignment to
subscripts can be used to set the components.</p>

<p>Dict d<br>
d[&quot;Paul Dubois&quot;] = &quot;(925)-422-5426&quot;</p>

<h3></a><a id="h_30">Interface for Class Dict</h3>

<p><em>Dict inherits from MapBase&lt;Object&gt;.</em></p>

<table border="1">
  <tr>
    <td><strong>Type&nbsp;&nbsp; </strong></td>
    <td><strong>Name</strong></td>
    <td><strong><p align="center">Comment</strong></td>
  </tr>
  <tr>
    <td>explicit</td>
    <td>Dict (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a id="h_30">)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>Dict (const Dict&amp; ob)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>Dict () </td>
    <td>Creates an empty dictionary</td>
  </tr>
  <tr>
    <td>Dict&amp;</td>
    <td>operator= (const Object&amp; rhs)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Dict&amp;</td>
    <td>operator= (PyObject* rhsp)</td>
    <td>&nbsp;</td>
  </tr>
</table>

<h1></a><a id="h_31">Other classes and facilities.</h1>

<p>Class Callable provides an interface to those Python objects that support a call
method. Class Module holds a pointer to a module. (If you want to create an extension
module, however, see the extension facility). There is a large set of numeric operators.</p>

<h3></a><a id="h_32">Interface to class Callable</h3>

<table border="1">
  <tr>
    <td><p align="center"><strong>Type</strong></td>
    <td><p align="center"><strong>Name</strong></td>
    <td><p align="center">Comment</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td>Callable (PyObject *pyob</a><a id="h_8">, bool owned = false</a><a id="h_32">)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Callable&amp;&nbsp;&nbsp; </td>
    <td>operator= (const Object&amp; rhs)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Callable&amp;&nbsp;&nbsp; </td>
    <td>operator= (PyObject* rhsp)</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Object</td>
    <td>apply(const Tuple&amp; args) const</td>
    <td>Call the object with the given arguments</td>
  </tr>
  <tr>
    <td>Object</td>
    <td>apply(PyObject* pargs = 0) const </td>
    <td>Call the object with args as the arguments. Checks that pargs is a tuple.</td>
  </tr>
</table>

<h3></a><a id="h_33">Interface to class Module</h3>

<table border="1" height="104">
  <tr>
    <td height="19"><p align="center"><strong>Type</strong></td>
    <td height="19"><p align="center"><strong>Name</strong></td>
    <td height="19"><p align="center"><strong>Comment</strong></td>
  </tr>
  <tr>
    <td height="23">explicit</td>
    <td height="23">Module (PyObject* pyob, bool owned = false)</td>
    <td height="23"></td>
  </tr>
  <tr>
    <td height="23">explicit</td>
    <td height="23">Module (const std::string name)</td>
    <td height="23">Construct from name of module; does the import if needed.</td>
  </tr>
  <tr>
    <td height="23"></td>
    <td height="23">Module (const Module&amp; ob)&nbsp;&nbsp; </td>
    <td height="23">Copy constructor</td>
  </tr>
  <tr>
    <td height="19">Module&amp;</td>
    <td height="19">operator= (const Object&amp; rhs)&nbsp;&nbsp; </td>
    <td height="19">Assignment</td>
  </tr>
  <tr>
    <td height="19">Module&amp;</td>
    <td height="19">operator= (PyObject* rhsp)&nbsp;&nbsp; </td>
    <td height="19">Assignment</td>
  </tr>
</table>

<h3></a><a id="h_34">Numeric interface</h3>

<p>Unary operators for plus and minus, and binary operators +, -, *, /, and % are defined
for pairs of objects and for objects with&nbsp; scalar integers or doubles (in either
order).&nbsp; Functions abs(ob) and coerce(o1, o2) are also defined. </p>

<p>The signature for coerce is:</p>

<p>inline std::pair&lt;Object,Object&gt; coerce(const Object&amp; a, const Object&amp; b)</p>

<p>Unlike the C API function, this simply returns the pair after coercion.</p>

<h3></a><a id="h_35">Stream I/O</h3>

<p>Any object can be printed using stream I/O, using std::ostream&amp; operator&lt;&lt;
(std::ostream&amp; os, const Object&amp; ob).&nbsp; The object's str() representation is
converted to a standard string which is passed to std::ostream&amp; operator&lt;&lt;
(std::ostream&amp; os, const std::string&amp;).</p>

<h2></a><a id="h_36">Exceptions</h2>

<p>The Python exception facility and the C++ exception facility can be merged via the use
of try/catch blocks in the bodies of extension objects and module functions.</p>

<h3></a><a id="h_37">Class Exception and its children</h3>

<p>A set of classes is provided. Each is derived from class Exception, and represents a
particular sort of Python exception, such as IndexError, RuntimeError, ValueError. Each of
them (other than Exception) has a constructor which takes an explanatory string as an
argument, and is used in a throw statement such as:</p>

<pre>throw IndexError(&quot;Index too large in MyObject access.&quot;);</pre>

<p>If in using a routine from the Python API, you discover that it has returned a NULL
indicating an error, then Python has already set the error message. In that case you
merely throw Exception.</p>

<h3></a><a id="h_38">List of Exceptions</h3>

<p>The exception hierarchy mirrors the Python exception hierarchy. The concrete exception
classes are shown here.</p>

<table border="1">
  <tr>
    <td>Type</td>
    <td><p align="center"><strong>Interface for class Exception</strong></td>
  </tr>
  <tr>
    <td>explicit&nbsp;&nbsp; </td>
    <td>Exception ()</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>Exception (const std::string&amp; reason) </td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>Exception (PyObject* exception, const std::string&amp; reason) </td>
  </tr>
  <tr>
    <td>void&nbsp;&nbsp; </td>
    <td>clear() </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td><p align="center"><strong>Constructors for other children of class Exception</strong></td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>TypeError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>IndexError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>AttributeError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>NameError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>RuntimeError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>SystemError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>KeyError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>ValueError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>OverflowError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>ZeroDivisionError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>MemoryError (const std::string&amp; reason)</td>
  </tr>
  <tr>
    <td>&nbsp;&nbsp; </td>
    <td>SystemExit (const std::string&amp; reason)</td>
  </tr>
</table>

<h2></a><a id="h_39">Using Exceptions in extension methods</h2>

<p>The exception facility allows you to integrate the C++ and Python exception mechanisms.
To do this, you must use the style described below when writing module methods in the old
C style. </p>

<p>Note: If using the ExtensionModule or PythonExtension mechanisms described below, the
method handlers include exception handling so that you only need to use exceptions
explicitly in unusual cases.</p>

<h3></a><a id="h_40">Catching Exceptions from the Python API or CXX.</h3>

<p>When writing an extension module method, you can use the following boilerplate. Any
exceptions caused by the Python API or CXX itself will be converted into a Python
exception. Note that Exception is the most general of the exceptions listed above, and
therefore this one catch clause will serve to catch all of them. You may wish to catch
other exceptions, not in the Exception family, in the same way. If so, you need to make
sure you set the error in Python before returning.</p>

<p>static PyObject *<br>
some_module_method(PyObject* self, PyObject* args)<br>
{<br>
&nbsp;&nbsp;&nbsp; Tuple a(args); // we know args is a Tuple<br>
&nbsp;&nbsp;&nbsp; try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...calculate something from a...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ...something, usually of the form
new_reference_to(some Object);<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; catch(const Exception&amp;) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Exception caught, passing it on to Python<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Null ();<br>
&nbsp;&nbsp;&nbsp; }<br>
} </p>

<h3></a><a id="h_41">How to clear an Exception</h3>

<p>If you anticipate that an Exception may be thrown and wish to recover from it, change
the catch phrase to set a reference to an Exception, and use the method clear() from class
Exception to clear it.:</p>

<blockquote>
  <p>catch(Exception&amp; e) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.clear();<br>
  ...now decide what to do about it...<br>
  }</p>
</blockquote>

<h2></a><a id="h_42">Extension Facilities</h2>

<p>CXX_Extensions.h provides facilities for: 

<ul>
  <li>Creating a Python extension module</li>
  <li>Creating new Python extension types</li>
</ul>

<p>These facilities use CXX_Objects.h and its support file cxxmodule.cxx, but not
vice-versa. Therefore, the decision about whether or not to use this part of CXX is up to
you. If you use CXX_Extensions.h you must also include source files cxxextensions.c and
cxx_extensions.cxx</p>

<h3></a><a id="h_43">Creating an Python extension module</h3>

<p>The usual method of creating a Python extension module is to declare and initialize its
method table in C. This requires knowledge of the correct form for the table and the order
in which entries are to be made into it, and requires casts to get everything to compile
without warning. CXX's header file PyExtensions.h offers a simpler method. Here is a
sample usage, in which a module named &quot;example&quot; is created. Note that two
details are necessary: 

<ul>
  <li>The initialization function must be declared to have external C linkage and to have the
    expected name. This is a requirement imposed by Python</li>
  <li>The ExtensionModule object must have a storage class that survives the call to the
    initialization function. This is most easily accomplished by using a static local inside
    the initialization function, as in initexample below.</li>
</ul>

<p>To create an extension module, you inherit from class ExtensionModule templated on
yourself: In the constructor, you make calls to register methods of this class with Python
as extension module methods. In this example, two methods are added (this is a simplified
form of the example in Demo/example.cxx):</p>

<p>class example_module : public ExtensionModule&lt;example_module&gt;<br>
{<br>
public:<br>
example_module()<br>
: ExtensionModule&lt;example_module&gt;( &quot;example&quot; )<br>
{<br>
add_varargs_method(&quot;sum&quot;, &amp;example_module::ex_sum, &quot;sum(arglist) = sum
of arguments&quot;);<br>
add_varargs_method(&quot;test&quot;, &amp;example_module::ex_test, &quot;test(arglist)
runs a test suite&quot;);<br>
<br>
initialize( &quot;documentation for the example module&quot; );<br>
}<br>
<br>
virtual ~example_module() {}<br>
<br>
private:<br>
Object ex_sum (const Tuple &amp;a) { ... }<br>
Object ex_test( const Tuple &amp;a) { ... }<br>
};<br>
</p>

<p>To initialize the extension, you just instantiate one static instance (static so it
doesn't destroy itself!):</p>

<p>void initexample()<br>
{<br>
static example_module* example = new example_module;<br>
}</p>

<p>The methods can be written to take Tuples as arguments and return Objects. If
exceptions occur they are trapped for you and a Python exception is generated. So, for
example, the implementation of ex_sum might be:</p>

<p>Object ex_sum (const Tuple &amp;a)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Float f(0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; a.length(); i++ )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Float g(a[i]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = f + g;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return f;<br>
&nbsp;&nbsp;&nbsp; }</p>

<p>class ExtensionModule contains methods to return itself as a Module object, or to
return its dictionary.</p>

<h3></a><a id="h_44">Interface to class ExtensionModule</h3>
<div align="left">

<table border="1">
  <tr>
    <td>Type&nbsp;&nbsp; </td>
    <td>Name&nbsp;&nbsp; </td>
    <td>Comment</td>
  </tr>
  <tr>
    <td>explicit</td>
    <td>ExtensionModule (char* name)&nbsp;&nbsp; </td>
    <td>Create an extension module named &quot;name&quot;</td>
  </tr>
  <tr>
    <td>virtual&nbsp;&nbsp; </td>
    <td>~ExtensionModule ()&nbsp;&nbsp; </td>
    <td>Destructor</td>
  </tr>
  <tr>
    <td>Dict</td>
    <td>moduleDictionary() const</td>
    <td>Returns the module dictionary; module must be initialized.</td>
  </tr>
  <tr>
    <td>Module</td>
    <td>module() const</td>
    <td>This module as a Module.</td>
  </tr>
  <tr>
    <td>void&nbsp;&nbsp; </td>
    <td>add_varargs_method (char *name,&nbsp; method_varargs_function_t method, char *
    documentation=&quot;&quot;)</td>
    <td>Add a method to the module.</td>
  </tr>
  <tr>
    <td>void </td>
    <td>add_keyword_method (char *name,&nbsp; method_keyword_function_t method, char
    *documentation=&quot;&quot;</td>
    <td>Add a method that takes keywords</td>
  </tr>
  <tr>
    <td>void</td>
    <td>initialize() (protected, call from constructor)</td>
    <td>Initialize the module once all methods have been added. </td>
  </tr>
</table>
</div>

<p></a>The signatures above are:<a id="h_45"></p>

<p>typedef Object (T::*method_varargs_function_t)( const Tuple &amp;args );<br>
typedef Object (T::*method_keyword_function_t)( const Tuple &amp;args, const Dict &amp;kws
);</p>

<p></a>That is, the methods take a Tuple or a Tuple and a Dict, and return an Object. The
example below has an &amp; in front of the name of the method; we found one compiler that
needed this.<a id="h_45"></p>

<h2>Creating a Python extension type</h2>

<p>One of the great things about Python is the way you can create your own object types
and have Python welcome them as first-class citizens. Unfortunately, part of the way you
have to do this is not great. Key to the process is the creation of a Python &quot;type
object&quot;. All instances of this type must share a reference to this one unique type
object.&nbsp; The type object itself has a multitude of &quot;slots&quot; into which the
addresses of functions can be added in order to give the object the desired behavior. </p>

<p></a><a id="h_43">Creating extension objects is of course harder since you must specify
how the object behaves and give it methods. This is shown in some detail in the example
r.h and r.cxx, with the test routine rtest.cxx, in directory Demo.</a> If you have never
created a Python extension before, you should read the Extension manual first and be very
familiar with Python's &quot;special class methods&quot;. Then what follows will make more
sense.<a id="h_45"></p>

<p>The basic idea is to inherit from PythonExtension templated on your self</p>

<p>class MyObject: public PythonExtension&lt;MyObject&gt; {...}</p>

<p>As a consequence: 

<ul>
  <li>MyObject is a child of PyObject, so that a MyObject* is-a PyObject*. </li>
  <li>A static method <em>check</em>(PyObject*) is created in class MyObject. This function
    returns a boolean, testing whether or not the argument is in fact a pointer to an instance
    of MyObject.</li>
  <li>The user can connect methods of MyObject to Python so that they are methods on MyObject
    objects. Each such method has the signature:<br>
    Object method_name (const Tuple&amp; args).</li>
  <li></a>The user can override virtual methods of PythonExtension in order to set behaviors.<a
    id="h_45"></li>
  <li>A method is created to handle the deletion of an instance if and when its reference
    count goes to zero. This method ensures the calling of the class destructor ~MyObject(),
    if any, and releases the memory (see below).</li>
  <li>Both automatic and heap-based instances of MyObject can be created.</li>
</ul>

<h3></a><a id="h_46">Sample usage of PythonExtension</h3>
</a><a id="h_43">

<p>Here is a brief overview. You create a class that inherits from PythonExtension
templated upon itself. You override various methods from PythonExtension to implement
behaviors, such as getattr, sequence_item, etc. You can also add methods to the object
that are usable from Python using a similar scheme as for module methods above. </p>

<p>One of the consequences of inheriting from PythonExtension is that you are inheriting
from PyObject itself. So your class is-a PyObject and instances of it can be passed to the
Python C API. Note: this example uses the namespace feature of CXX. The Py:: 's are not
required if you are &quot;using&quot; the namespace instead.</p>

<p>class r: public Py::PythonExtension&lt;r&gt; {<br>
public:<br>
... constructors, data, etc.<br>
... methods not callable from Python<br>
// initializer, see below<br>
&nbsp;&nbsp;&nbsp;&nbsp; static void init_type();<br>
// override functions from PythonExtension<br>
&nbsp;&nbsp;&nbsp; virtual Py::Object repr();<br>
&nbsp;&nbsp;&nbsp; virtual Py::Object getattr( const char *name );<br>
<br>
&nbsp;&nbsp; virtual int sequence_length();<br>
&nbsp;&nbsp; virtual Py::Object sequence_item( int i );<br>
&nbsp;&nbsp;&nbsp; virtual Py::Object sequence_concat( const Py::Object &amp;j );<br>
&nbsp;&nbsp;&nbsp; virtual Py::Object sequence_slice( int i, int j );<br>
<br>
// define python methods of this object<br>
&nbsp;&nbsp;&nbsp; Py::Object amethod (const Py::Tuple&amp; args);<br>
&nbsp;&nbsp;&nbsp; Py::Object value (const Py::Tuple&amp; args);<br>
&nbsp;&nbsp;&nbsp; Py::Object assign (const Py::Tuple&amp; args); <br>
};</p>

<p><br>
To initialize the type we provide a static method that we can call from some module's
initializer. We set the name, doc string, and indicate which behaviors r objects &nbsp;
support. Then we adds the methods.</p>

<p>void r::init_type()<br>
{<br>
&nbsp;&nbsp;&nbsp; behaviors().name(&quot;r&quot;);<br>
&nbsp;&nbsp;&nbsp; behaviors().doc(&quot;r objects: start, stop, step&quot;);<br>
&nbsp;&nbsp;&nbsp; behaviors().supportRepr();<br>
&nbsp;&nbsp;&nbsp; behaviors().supportGetattr();<br>
&nbsp;&nbsp;&nbsp; behaviors().supportSequenceType();<br>
<br>
&nbsp;&nbsp;&nbsp; add_varargs_method(&quot;amethod&quot;, &amp;r::amethod,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;demonstrate how to document
amethod&quot;);<br>
&nbsp;&nbsp;&nbsp; add_varargs_method(&quot;assign&quot;, &amp;r::assign);<br>
&nbsp;&nbsp;&nbsp; add_varargs_method(&quot;value&quot;, &amp;r::value);<br>
}</p>
</a>

<p>Don't forget to add the call r::init_type() to some module's init function. You'll want
a method in some module that can create r objects, too.</p>

<h3>Interface to PythonExtension &lt;T&gt;</h3>

<p>Your extension class T inherits PythonExtension&lt;T&gt;.</p>
<a id="h_44"><div align="left">

<table border="1">
  <tr>
    <td>Type&nbsp;&nbsp; </td>
    <td>Name&nbsp;&nbsp; </td>
    <td>Comment</td>
  </tr>
  <tr>
    <td>virtual&nbsp;&nbsp; </td>
    <td>~PythonExtension&lt;T&gt;()&nbsp;&nbsp; </td>
    <td>Destructor</td>
  </tr>
  <tr>
    <td>PyTypeObject* </td>
    <td>type_object() const</td>
    <td>Returns the object type object.</td>
  </tr>
  <tr>
    <td>int</td>
    <td>check (PyObject* p)</td>
    <td>Is p a T?</td>
  </tr>
  <tr>
    <td colspan="3"><strong>Protected </strong></td>
  </tr>
  <tr>
    <td>void </td>
    <td>add_varargs_method (char *name,&nbsp; method_keyword_function_t method, char
    *documentation=&quot;&quot;</td>
    <td>Add a method that takes arguments</td>
  </tr>
  <tr>
    <td>void </td>
    <td>add_keyword_method (char *name,&nbsp; method_keyword_function_t method, char
    *documentation=&quot;&quot;</td>
    <td>Add a method that takes keywords</td>
  </tr>
  <tr>
    <td>static PythonType&amp;</td>
    <td>behaviors()</td>
    <td>The type object</td>
  </tr>
  <tr>
    <td>void</td>
    <td>initialize() (protected, call from constructor)</td>
    <td>Initialize the module once all methods have been added. </td>
  </tr>
</table>
</div></a><a id="h_46">

<p></a> As before the signatures for the methods are Object mymethod(const Tuple&amp;
args) and Object mykeywordmethod (const Tuple&amp; args, const Dict&amp; keys). In this
case, the methods must be methods of T.<a id="h_47"></p>

<p>To set the behaviors of the object you override some or all of these methods from
PythonExtension&lt;T&gt;:</p>

<p>&nbsp;&nbsp;&nbsp; virtual int print( FILE *, int );<br>
&nbsp;&nbsp;&nbsp; virtual Object getattr( const char * );<br>
&nbsp;&nbsp;&nbsp; virtual int setattr( const char *, const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object getattro( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual int setattro( const Object &amp;, const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual int compare( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object repr();<br>
&nbsp;&nbsp;&nbsp; virtual Object str();<br>
&nbsp;&nbsp;&nbsp; virtual long hash();<br>
&nbsp;&nbsp;&nbsp; virtual Object call( const Object &amp;, const Object &amp; );<br>
<br>
&nbsp;&nbsp;&nbsp; // Sequence methods<br>
&nbsp;&nbsp;&nbsp; virtual int sequence_length();<br>
&nbsp;&nbsp;&nbsp; virtual Object sequence_concat( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object sequence_repeat( int );<br>
&nbsp;&nbsp;&nbsp; virtual Object sequence_item( int );<br>
&nbsp;&nbsp;&nbsp; virtual Object sequence_slice( int, int );<br>
&nbsp;&nbsp;&nbsp; virtual int sequence_ass_item( int, const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual int sequence_ass_slice( int, int, const Object &amp; );<br>
<br>
&nbsp;&nbsp;&nbsp; // Mapping<br>
&nbsp;&nbsp;&nbsp; virtual int mapping_length();<br>
&nbsp;&nbsp;&nbsp; virtual Object mapping_subscript( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual int mapping_ass_subscript( const Object &amp;, const Object
&amp; );<br>
<br>
&nbsp;&nbsp;&nbsp; // Number<br>
&nbsp;&nbsp;&nbsp; virtual int number_nonzero();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_negative();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_positive();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_absolute();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_invert();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_int();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_float();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_long();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_oct();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_hex();<br>
&nbsp;&nbsp;&nbsp; virtual Object number_add( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_subtract( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_multiply( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_divide( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_remainder( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_divmod( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_lshift( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_rshift( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_and( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_xor( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_or( const Object &amp; );<br>
&nbsp;&nbsp;&nbsp; virtual Object number_power( const Object &amp;, const Object &amp; );<br>
<br>
&nbsp;&nbsp;&nbsp; // Buffer<br>
&nbsp;&nbsp;&nbsp; virtual int buffer_getreadbuffer( int, void** );<br>
&nbsp;&nbsp;&nbsp; virtual int buffer_getwritebuffer( int, void** );<br>
&nbsp;&nbsp;&nbsp; virtual int buffer_getsegcount( int* );</p>

<p>Note that dealloc is not one of the functions you can override. That's what your
destructor is for. As noted below, dealloc behavior is provided for you by
PythonExtension.<br>
</a><a id="h_47"></p>

<h3></a>Type initialization<a id="h_47"></h3>

<p></a>To initialize your type, supply a static public member function that can be called
from the extension module. In that function, obtain the PythonType object by calling
behaviors() and apply appropriate &quot;support&quot; methods from PythonType to turn on
the support for that behavior or set of behaviors.<a id="h_47"></p>

<p>&nbsp;&nbsp;&nbsp; void supportPrint(void);<br>
&nbsp;&nbsp;&nbsp; void supportGetattr(void);<br>
&nbsp;&nbsp;&nbsp; void supportSetattr(void);<br>
&nbsp;&nbsp;&nbsp; void supportGetattro(void);<br>
&nbsp;&nbsp;&nbsp; void supportSetattro(void);<br>
&nbsp;&nbsp;&nbsp; void supportCompare(void);<br>
&nbsp;&nbsp;&nbsp; void supportRepr(void);<br>
&nbsp;&nbsp;&nbsp; void supportStr(void);<br>
&nbsp;&nbsp;&nbsp; void supportHash(void);<br>
&nbsp;&nbsp;&nbsp; void supportCall(void);<br>
<br>
&nbsp;&nbsp;&nbsp; void supportSequenceType(void);<br>
&nbsp;&nbsp;&nbsp; void supportMappingType(void);<br>
&nbsp;&nbsp;&nbsp; void supportNumberType(void);<br>
&nbsp;&nbsp;&nbsp; void supportBufferType(void);</p>

<p>Then call add_varargs_method or add_keyword_method to add any methods desired to the
object.</p>

<h3>Notes on memory management and extension objects</h3>

<p>Normal Python objects exist only on the heap. That is unfortunate, as object creation
and destruction can be relatively expensive. Class PythonExtension allows creation of both
local and heap-based objects. </p>

<p>If an extension object is created using operator new, as in:</p>

<p>r* my_r_ref = new r(1, 20, 3)</p>

<p>then the entity my_r_ref can be thought of as &quot;owning&quot; the reference created
in the new object. Thus, the object will never have a reference count of zero. If the
creator wishes to delete this object, they should either make sure the reference count is
1 and then do delete my_r_ref, or decrement the reference with Py_DECREF(my_r_ref).</p>

<p>Should my_r_ref give up ownership by being used in an Object constructor, all will
still be well. When the Object goes out of scope its destructor will be called, and that
will decrement the reference count, which in turn will trigger the special dealloc routine
that calls the destructor and deletes the pointer.</p>

<p>If the object is created with automatic scope, as in:</p>

<p>r my_r(1, 20, 3)</p>

<p>then my_r can be thought of as owning the reference, and when my_r goes out of scope
the object will be destroyed. Of course, care must be taken not to have kept any permanent
reference to this object. Fortunately, in the case of an exception, the C++ exception
facility will call the destructor of my_r. Naturally, care must be taken not to end up
with a dangling reference, but such objects can be created and destroyed more efficiently
than heap-based PyObjects.</p>

<h2></a><a id="h_48">Putting it all together</h2>

<p>The Demo directory of the distribution contains an extensive example of how to use many
of the facilities in CXX. It also serves as a test routine. This test is not completely
exhaustive but does excercise much of the facility.</p>

<h2></a><a id="h_49">Acknowledgment</h2>

<p>Thank you to Geoffrey Furnish for patiently teaching me the finer points of C++ and its
template facility, and his critique of CXX in particular. With version 4 I welcome Barry
Scott as co-author. -- Paul Dubois</p>
</a>
</body>
</html>
